
#pragma once

#include "System/Delegate.h"
#include "System/EventArgs.h"
#include <vector>
#include <memory>
#include <functional>
#include <atomic>
#include <algorithm>
#include <mutex>

namespace System
{
    /// <summary>
    /// Represents the method that will handle an event that has no event data.
    /// </summary>
    using BasicEventHandler = TypedDelegate<void(Object*, EventArgs*)>;

    /// <summary>
    /// Represents the method that will handle an event.
    /// </summary>
    /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
    template<typename TEventArgs>
    using EventHandlerT = TypedDelegate<void(Object*, TEventArgs*)>;

    /// <summary>
    /// Represents the method that will handle the PropertyChanged event raised when a property is changed on a component.
    /// </summary>
    using PropertyChangedEventHandler = EventHandlerT<PropertyChangedEventArgs>;

    /// <summary>
    /// Represents the method that will handle the CollectionChanged event.
    /// </summary>
    using CollectionChangedEventHandler = EventHandlerT<CollectionChangedEventArgs>;

    /// <summary>
    /// Represents the method that will handle the event raised by an unhandled exception.
    /// </summary>
    using UnhandledExceptionEventHandler = EventHandlerT<UnhandledExceptionEventArgs>;

    /// <summary>
    /// Thread-safe event implementation that manages multicast delegates.
    /// </summary>
    /// <typeparam name="TEventArgs">The type of event arguments.</typeparam>
    template<typename TEventArgs = EventArgs>
    class Event
    {
    private:
        mutable std::mutex m_mutex;
        std::vector<EventHandlerT<TEventArgs>> m_handlers;
        std::atomic<bool> m_isRaising{false};

    public:
        /// <summary>
        /// Initializes a new instance of the Event class.
        /// </summary>
        Event() = default;

        /// <summary>
        /// Copy constructor - creates a copy of the event handlers.
        /// </summary>
        Event(const Event& other)
        {
            std::lock_guard<std::mutex> lock(other.m_mutex);
            m_handlers = other.m_handlers;
        }

        /// <summary>
        /// Move constructor.
        /// </summary>
        Event(Event&& other) noexcept
        {
            std::lock_guard<std::mutex> lock(other.m_mutex);
            m_handlers = std::move(other.m_handlers);
            other.m_handlers.clear();
        }

        /// <summary>
        /// Copy assignment operator.
        /// </summary>
        Event& operator=(const Event& other)
        {
            if (this != &other)
            {
                // Lock both mutexes in a consistent order to prevent deadlock
                std::lock(m_mutex, other.m_mutex);
                std::lock_guard<std::mutex> lock1(m_mutex, std::adopt_lock);
                std::lock_guard<std::mutex> lock2(other.m_mutex, std::adopt_lock);
                m_handlers = other.m_handlers;
            }
            return *this;
        }

        /// <summary>
        /// Move assignment operator.
        /// </summary>
        Event& operator=(Event&& other) noexcept
        {
            if (this != &other)
            {
                std::lock(m_mutex, other.m_mutex);
                std::lock_guard<std::mutex> lock1(m_mutex, std::adopt_lock);
                std::lock_guard<std::mutex> lock2(other.m_mutex, std::adopt_lock);
                m_handlers = std::move(other.m_handlers);
                other.m_handlers.clear();
            }
            return *this;
        }

        /// <summary>
        /// Destructor.
        /// </summary>
        ~Event() = default;

        /// <summary>
        /// Adds an event handler to the event.
        /// </summary>
        /// <param name="handler">The event handler to add.</param>
        void Add(const EventHandlerT<TEventArgs>& handler)
        {
            if (handler.IsNull())
                return;

            std::lock_guard<std::mutex> lock(m_mutex);
            m_handlers.push_back(handler);
        }

        /// <summary>
        /// Removes an event handler from the event.
        /// </summary>
        /// <param name="handler">The event handler to remove.</param>
        void Remove(const EventHandlerT<TEventArgs>& handler)
        {
            if (handler.IsNull())
                return;

            std::lock_guard<std::mutex> lock(m_mutex);
            auto it = std::find_if(m_handlers.begin(), m_handlers.end(),
                [&handler](const EventHandlerT<TEventArgs>& h) {
                    return h.Equals(handler);
                });
            
            if (it != m_handlers.end())
            {
                m_handlers.erase(it);
            }
        }

        /// <summary>
        /// Raises the event, invoking all registered handlers.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="args">The event arguments.</param>
        void Raise(Object* sender, TEventArgs* args)
        {
            // Prevent recursive event raising
            if (m_isRaising.exchange(true))
                return;

            std::vector<EventHandlerT<TEventArgs>> handlersCopy;
            
            // Copy handlers under lock
            {
                std::lock_guard<std::mutex> lock(m_mutex);
                handlersCopy = m_handlers;
            }

            // Invoke handlers outside of lock to prevent deadlocks
            for (const auto& handler : handlersCopy)
            {
                try
                {
                    if (!handler.IsNull())
                    {
                        handler.Invoke(sender, args);
                    }
                }
                catch (...)
                {
                    // Continue invoking other handlers even if one throws
                    // In a production system, you might want to log this exception
                }
            }
            
            m_isRaising.store(false);
        }

        /// <summary>
        /// Gets the number of registered event handlers.
        /// </summary>
        /// <returns>The number of registered event handlers.</returns>
        size_t GetHandlerCount() const
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            return m_handlers.size();
        }

        /// <summary>
        /// Removes all event handlers.
        /// </summary>
        void Clear()
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            m_handlers.clear();
        }

        /// <summary>
        /// Checks if the event has any registered handlers.
        /// </summary>
        /// <returns>true if there are registered handlers; otherwise, false.</returns>
        bool HasHandlers() const
        {
            return GetHandlerCount() > 0;
        }

        /// <summary>
        /// Operator += for adding event handlers.
        /// </summary>
        Event& operator+=(const EventHandlerT<TEventArgs>& handler)
        {
            Add(handler);
            return *this;
        }

        /// <summary>
        /// Operator -= for removing event handlers.
        /// </summary>
        Event& operator-=(const EventHandlerT<TEventArgs>& handler)
        {
            Remove(handler);
            return *this;
        }

        /// <summary>
        /// Operator () for raising the event.
        /// </summary>
        void operator()(Object* sender, TEventArgs* args)
        {
            Raise(sender, args);
        }
    };

    /// <summary>
    /// Specialization for EventArgs.
    /// </summary>
    using BasicEvent = Event<EventArgs>;
}

// Event declaration and implementation macros
#define DECLARE_EVENT(EventType, EventName) \
    private: \
        System::Event<EventType> m_##EventName##Event; \
    public: \
        void add_##EventName(const System::EventHandlerT<EventType>& handler) { m_##EventName##Event.Add(handler); } \
        void remove_##EventName(const System::EventHandlerT<EventType>& handler) { m_##EventName##Event.Remove(handler); } \
    protected: \
        virtual void On##EventName(EventType* args) { m_##EventName##Event.Raise(this, args); }

#define DECLARE_BASIC_EVENT(EventName) \
    private: \
        System::Event<System::EventArgs> m_##EventName##Event; \
    public: \
        void add_##EventName(const System::BasicEventHandler& handler) { m_##EventName##Event.Add(handler); } \
        void remove_##EventName(const System::BasicEventHandler& handler) { m_##EventName##Event.Remove(handler); } \
    protected: \
        virtual void On##EventName(System::EventArgs* args) { m_##EventName##Event.Raise(this, args); }

#define RAISE_EVENT(EventName, args) \
    On##EventName(args)

#define EVENT_HANDLER(ReturnType, MethodName, EventArgsType) \
    ReturnType MethodName(System::Object* sender, EventArgsType* args)

// Helper macros for common event patterns
#define DECLARE_PROPERTY_CHANGED_EVENT() \
    DECLARE_EVENT(System::PropertyChangedEventArgs, PropertyChanged)

#define DECLARE_COLLECTION_CHANGED_EVENT() \
    DECLARE_EVENT(System::CollectionChangedEventArgs, CollectionChanged)

#define RAISE_PROPERTY_CHANGED(propertyName) \
    do { \
        auto args = System::PropertyChangedEventArgs(propertyName); \
        RAISE_EVENT(PropertyChanged, &args); \
    } while(0)

#define RAISE_COLLECTION_CHANGED(action, index) \
    do { \
        auto args = System::CollectionChangedEventArgs(action, index); \
        RAISE_EVENT(CollectionChanged, &args); \
    } while(0)
